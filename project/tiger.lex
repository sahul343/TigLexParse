(* Internal datatypes and functions required by the lexer *)
(* Keeping track of position in source                    *)

type lineNo            = int
type pos               = lineNo  (* The type of Should match with Tiger.yacc *)
val  lineRef : pos ref = ref 0   (* reference variable to keep track of position.
				    Typing not necessary just for clarity *)

fun updateLine n      = lineRef := !(lineRef) + n

(* Stuff done to make use of the Tokens module generated by Tiger.grm *)

type svalue        = Tokens.svalue
type ('a,'b) token = ('a,'b) Tokens.token
type lexresult     = (svalue,pos) token
val commentDepth = ref 0
val comment = ref ""
fun lineRange l r = "line " ^ l
				  (*else ("line " ^ Int.toString l ^ "-" ^ Int.toString r)*)
fun error (e,l,r) = TextIO.output(TextIO.stdErr, lineRange l r ^ ":" ^ e ^ "\n")

(*
   What to return at the end of the file. Note the extra (!pos,!pos). If you have
   the clause

   %term FOO of int  | BAR

   The token module will have two functions which are

   Token.FOO : int * pos * pos
   Token.BAR : pos * pos

   Here we give the eof function for the lexer which should return the
   EOF terminal to the parser.

*)
fun eof   ()      = Tokens.EOF (!lineRef,!lineRef)

(* Some helper functions during lexing *)

fun charsToInt m (x :: xs) = charsToInt (10 * m + ord x - ord #"0") xs
  | charsToInt m []        = m

fun toSigned (#"-" :: xs) = ~ (charsToInt 0 xs)
  | toSigned (#"~" :: xs) = ~ (charsToInt 0 xs)
  | toSigned (#"+" :: xs) =   charsToInt 0 xs
  | toSigned xs           =   charsToInt 0 xs

val toInt        = toSigned o String.explode

val newlineCount = List.length o List.filter (fn x => x = #"\n") o String.explode

%%

%header (functor TigerLexFun(structure Tokens : Tiger_TOKENS));
%s COMMENT;
ws    = [\ \t];
digit = [0-9]+;
letter = [a-zA-Z];
id  = [a-zA-Z]([a-z_A-Z1-9])*;
comment = "/*"([^*]|\*+[^*/])*\*+"/";
cstart = "/*";
cend = "*/";
%%
<INITIAL>{ws}+         => ( lex() );
<INITIAL>\n({ws}*\n)*  => ( updateLine (newlineCount yytext) ;lex()(*Tokens.NEWLINE (!lineRef, !lineRef)*));
<INITIAL>{digit}      => ( Tokens.CONST (toInt yytext, !lineRef, !lineRef) );
<COMMENT>"/*"		=> (commentDepth := (!commentDepth + 1); lex());
<INITIAL>"/*"		=> (commentDepth := (!commentDepth + 1); YYBEGIN COMMENT; lex());
<COMMENT>"*/"		=> (commentDepth := (!commentDepth - 1); if (!commentDepth)=0 then (YYBEGIN INITIAL; print(!comment) ) else () ;lex());
<COMMENT>.		=>(comment := (!comment^yytext);lex() );
<INITIAL>"nil"           => ( Tokens.NIL  (!lineRef,!lineRef) );
<INITIAL>"+"           => ( Tokens.PLUS  (!lineRef,!lineRef) );
<INITIAL>"-"           => ( Tokens.MINUS  (!lineRef,!lineRef) );
<INITIAL>"*"           => ( Tokens.MUL (!lineRef,!lineRef) );
<INITIAL>"/"           => ( Tokens.DIV (!lineRef,!lineRef) );
<INITIAL>"="           => ( Tokens.EQ (!lineRef,!lineRef) );
<INITIAL>"<="           => ( Tokens.LTEQ (!lineRef,!lineRef) );
<INITIAL>">="           => ( Tokens.GTEQ (!lineRef,!lineRef) );
<INITIAL>"<>"           => ( Tokens.NTEQ (!lineRef,!lineRef) );
<INITIAL>"&"           => ( Tokens.AND (!lineRef,!lineRef) );
<INITIAL>"|"           => ( Tokens.OR (!lineRef,!lineRef) );
<INITIAL>"<"           => ( Tokens.LT (!lineRef,!lineRef) );
<INITIAL>">"           => ( Tokens.GT (!lineRef,!lineRef) );
<INITIAL>";"           => ( Tokens.SEMICOLON (!lineRef,!lineRef) );
<INITIAL>":="	      => ( Tokens.ASSIGN (!lineRef,!lineRef) );
<INITIAL>"if"	      => ( Tokens.IF  (yypos,yypos+2) );
<INITIAL>"("	      => ( Tokens.LPAREN (!lineRef,!lineRef) );
<INITIAL>")"	      => ( Tokens.RPAREN (!lineRef,!lineRef) );
<INITIAL>"["           => ( Tokens.LBRACK (!lineRef,!lineRef) );
<INITIAL>"]"           => ( Tokens.RBRACK (!lineRef,!lineRef) );
<INITIAL>"{"           => ( Tokens.LBRACE (!lineRef,!lineRef) );
<INITIAL>"}"           => ( Tokens.RBRACE (!lineRef,!lineRef) );
<INITIAL>"."           => ( Tokens.DOT (!lineRef,!lineRef) );
<INITIAL>","           => ( Tokens.COMMA (!lineRef,!lineRef) );
<INITIAL>":"           => ( Tokens.COLON (!lineRef,!lineRef) );
<INITIAL>"new"	      => ( Tokens.NEW	(!lineRef,!lineRef));
<INITIAL>"while"	      => ( Tokens.WHILE (!lineRef,!lineRef) );
<INITIAL>"do"	      => ( Tokens.DO (!lineRef,!lineRef) );
<INITIAL>"for"	      => ( Tokens.FOR (!lineRef,!lineRef) );
<INITIAL>"to"	      => ( Tokens.TO (!lineRef,!lineRef) );
<INITIAL>"else"	      => ( Tokens.ELSE (!lineRef,!lineRef) );
<INITIAL>"then"	      => ( Tokens.THEN (!lineRef,!lineRef) );
<INITIAL>"break"	      => ( Tokens.BREAK (!lineRef,!lineRef) );
<INITIAL>"let"	      => ( Tokens.LET (!lineRef,!lineRef) );
<INITIAL>"in"	      => ( Tokens.IN (!lineRef,!lineRef) );
<INITIAL>"end"	      => ( Tokens.END (!lineRef,!lineRef) );
<INITIAL>"var"	      => ( Tokens.VAR (!lineRef,!lineRef) );
<INITIAL>"nil"	      => ( Tokens.NIL (!lineRef,!lineRef) );
<INITIAL>"of"	      => ( Tokens.OF (!lineRef,!lineRef) );
<INITIAL>"import"      => ( Tokens.IMPORT (!lineRef,!lineRef) );
<INITIAL>"function"      => ( Tokens.FUNCTION (!lineRef,!lineRef) );
<INITIAL>"primitive"      => ( Tokens.PRIMITIVE (!lineRef,!lineRef) );
<INITIAL>"type"      => ( Tokens.TYPE (!lineRef,!lineRef) );
<INITIAL>"array"      => ( Tokens.ARRAY (!lineRef,!lineRef) );
<INITIAL>"method"      => ( Tokens.METHOD (!lineRef,!lineRef) );
<INITIAL>"class"      => ( Tokens.CLASS (!lineRef,!lineRef) );
<INITIAL>"extends"      => ( Tokens.EXTENDS (!lineRef,!lineRef) );
<INITIAL>"\"".*"\""     => ( Tokens.QUOTE (yytext,!lineRef,!lineRef) );
<INITIAL>{id}|"_main"  => (Tokens.ID (yytext,!lineRef, !lineRef) );
